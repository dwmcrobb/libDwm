<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<title>libDwm-0.0.20240716: Dwm::Thread::Queue&lt; _ValueType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width=100%>
 <tbody>
 <tr style="height: 56px;">
  <td>&nbsp;</td>
  <td id="projectlogo">&nbsp;<img alt="Logo" src="libDwm_blue_base.svg" height=40 align="left" style="vertical-align: top;"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libDwm-0.0.20240716
   </div>
  </td>
  <td><a href="http://www.mcplex.net"><img src="mcplex_net_blue_shadowed.svg" height=35 align="right" style="vertical-align: bottom;"></a></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',true);
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classDwm_1_1Thread_1_1Queue.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classDwm_1_1Thread_1_1Queue-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Dwm::Thread::Queue&lt; _ValueType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This template provides inter-thread first-in first-out (FIFO) queueing.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="DwmThreadQueue_8hh_source.html">DwmThreadQueue.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af393abea033987dbf163e7ed03f9ebdf" id="r_af393abea033987dbf163e7ed03f9ebdf"><td class="memItemLeft" align="right" valign="top"><a id="af393abea033987dbf163e7ed03f9ebdf" name="af393abea033987dbf163e7ed03f9ebdf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Queue</b> ()</td></tr>
<tr class="memdesc:af393abea033987dbf163e7ed03f9ebdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:af393abea033987dbf163e7ed03f9ebdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8398e55a51fdfedea1688c806260315a" id="r_a8398e55a51fdfedea1688c806260315a"><td class="memItemLeft" align="right" valign="top"><a id="a8398e55a51fdfedea1688c806260315a" name="a8398e55a51fdfedea1688c806260315a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~Queue</b> ()</td></tr>
<tr class="memdesc:a8398e55a51fdfedea1688c806260315a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a8398e55a51fdfedea1688c806260315a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82cc337977e16ddc981b44ca2c2176b9" id="r_a82cc337977e16ddc981b44ca2c2176b9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82cc337977e16ddc981b44ca2c2176b9">MaxLength</a> () const</td></tr>
<tr class="memdesc:a82cc337977e16ddc981b44ca2c2176b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the max length of the queue.  <br /></td></tr>
<tr class="separator:a82cc337977e16ddc981b44ca2c2176b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401c683ee984e86844e0a1911df5c7a3" id="r_a401c683ee984e86844e0a1911df5c7a3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a401c683ee984e86844e0a1911df5c7a3">MaxLength</a> (uint32_t maxLength)</td></tr>
<tr class="memdesc:a401c683ee984e86844e0a1911df5c7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets and returns the max length of the queue.  <br /></td></tr>
<tr class="separator:a401c683ee984e86844e0a1911df5c7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09704520e6df7b1ef6e087210e8352fa" id="r_a09704520e6df7b1ef6e087210e8352fa"><td class="memItemLeft" align="right" valign="top"><a id="a09704520e6df7b1ef6e087210e8352fa" name="a09704520e6df7b1ef6e087210e8352fa"></a>
std::deque&lt; _ValueType &gt;::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>Length</b> () const</td></tr>
<tr class="memdesc:a09704520e6df7b1ef6e087210e8352fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current length of the queue. <br /></td></tr>
<tr class="separator:a09704520e6df7b1ef6e087210e8352fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab299aa8a99b55ca3d8060318b3929cd3" id="r_ab299aa8a99b55ca3d8060318b3929cd3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab299aa8a99b55ca3d8060318b3929cd3">PushBack</a> (const _ValueType &amp;value)</td></tr>
<tr class="memdesc:ab299aa8a99b55ca3d8060318b3929cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts <code>value</code> on the back of the queue.  <br /></td></tr>
<tr class="separator:ab299aa8a99b55ca3d8060318b3929cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545b4b17f7ffadeec717e66a3a73bef0" id="r_a545b4b17f7ffadeec717e66a3a73bef0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a545b4b17f7ffadeec717e66a3a73bef0">PushBack</a> (_ValueType &amp;&amp;value)</td></tr>
<tr class="memdesc:a545b4b17f7ffadeec717e66a3a73bef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts <code>value</code> on the back of the queue.  <br /></td></tr>
<tr class="separator:a545b4b17f7ffadeec717e66a3a73bef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0745cdf8d3b529ca3bb01c5340b394e5" id="r_a0745cdf8d3b529ca3bb01c5340b394e5"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a0745cdf8d3b529ca3bb01c5340b394e5"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0745cdf8d3b529ca3bb01c5340b394e5">PushBack</a> (InputIterator firstIter, InputIterator lastIter)</td></tr>
<tr class="memdesc:a0745cdf8d3b529ca3bb01c5340b394e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the values from firstIter to lastIter on the back of the queue.  <br /></td></tr>
<tr class="separator:a0745cdf8d3b529ca3bb01c5340b394e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9097a3aaf8a60e73dbbe92d6398a66a" id="r_ab9097a3aaf8a60e73dbbe92d6398a66a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9097a3aaf8a60e73dbbe92d6398a66a">PushFront</a> (const _ValueType &amp;value)</td></tr>
<tr class="memdesc:ab9097a3aaf8a60e73dbbe92d6398a66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts <code>value</code> on the front of the queue.  <br /></td></tr>
<tr class="separator:ab9097a3aaf8a60e73dbbe92d6398a66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82175a3c3310cb5a312039fcf24e7944" id="r_a82175a3c3310cb5a312039fcf24e7944"><td class="memTemplParams" colspan="2"><a id="a82175a3c3310cb5a312039fcf24e7944" name="a82175a3c3310cb5a312039fcf24e7944"></a>
template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a82175a3c3310cb5a312039fcf24e7944"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PushFront</b> (InputIterator firstIter, InputIterator lastIter)</td></tr>
<tr class="separator:a82175a3c3310cb5a312039fcf24e7944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1576afd114e7acc61cc7bed18f9471e" id="r_af1576afd114e7acc61cc7bed18f9471e"><td class="memItemLeft" align="right" valign="top"><a id="af1576afd114e7acc61cc7bed18f9471e" name="af1576afd114e7acc61cc7bed18f9471e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ConditionSignal</b> ()</td></tr>
<tr class="memdesc:af1576afd114e7acc61cc7bed18f9471e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unblocks at least one thread waiting on the condition variable. <br /></td></tr>
<tr class="separator:af1576afd114e7acc61cc7bed18f9471e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b401fa39361443175d566b0c738319" id="r_a69b401fa39361443175d566b0c738319"><td class="memItemLeft" align="right" valign="top"><a id="a69b401fa39361443175d566b0c738319" name="a69b401fa39361443175d566b0c738319"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ConditionWait</b> ()</td></tr>
<tr class="memdesc:a69b401fa39361443175d566b0c738319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the condition variable to be signalled or broadcasted. <br /></td></tr>
<tr class="separator:a69b401fa39361443175d566b0c738319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52812a90c5f415aa1ed6c37823a29947" id="r_a52812a90c5f415aa1ed6c37823a29947"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period &gt; </td></tr>
<tr class="memitem:a52812a90c5f415aa1ed6c37823a29947"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a52812a90c5f415aa1ed6c37823a29947">ConditionTimedWait</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;timeToWait)</td></tr>
<tr class="memdesc:a52812a90c5f415aa1ed6c37823a29947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the condition variable to be signalled or broadcasted for timeToWait to pass.  <br /></td></tr>
<tr class="separator:a52812a90c5f415aa1ed6c37823a29947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e201afc119ed280ad25760b65ffedb" id="r_ab2e201afc119ed280ad25760b65ffedb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2e201afc119ed280ad25760b65ffedb">PopFront</a> (_ValueType &amp;value)</td></tr>
<tr class="memdesc:ab2e201afc119ed280ad25760b65ffedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops the entry from the front of the queue and stores it in <code>value</code>.  <br /></td></tr>
<tr class="separator:ab2e201afc119ed280ad25760b65ffedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b1293f4022a52dcd07955477f1bbbb" id="r_a64b1293f4022a52dcd07955477f1bbbb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64b1293f4022a52dcd07955477f1bbbb">PopBack</a> (_ValueType &amp;value)</td></tr>
<tr class="memdesc:a64b1293f4022a52dcd07955477f1bbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops the entry from the back of the queue and stores it in <code>value</code>.  <br /></td></tr>
<tr class="separator:a64b1293f4022a52dcd07955477f1bbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e9203f20d26df3ed6f8722aff22eb1" id="r_a67e9203f20d26df3ed6f8722aff22eb1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67e9203f20d26df3ed6f8722aff22eb1">WaitForNotEmpty</a> ()</td></tr>
<tr class="memdesc:a67e9203f20d26df3ed6f8722aff22eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the calling thread until the queue contains at least one entry.  <br /></td></tr>
<tr class="separator:a67e9203f20d26df3ed6f8722aff22eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba47d22548f5b720af4ed663c9d3803" id="r_afba47d22548f5b720af4ed663c9d3803"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period &gt; </td></tr>
<tr class="memitem:afba47d22548f5b720af4ed663c9d3803"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afba47d22548f5b720af4ed663c9d3803">TimedWaitForNotEmpty</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;timeToWait)</td></tr>
<tr class="memdesc:afba47d22548f5b720af4ed663c9d3803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits <code>timeToWait</code> for the queue to be non-empty.  <br /></td></tr>
<tr class="separator:afba47d22548f5b720af4ed663c9d3803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da29874dd75caeb07dc2f231d677543" id="r_a1da29874dd75caeb07dc2f231d677543"><td class="memItemLeft" align="right" valign="top"><a id="a1da29874dd75caeb07dc2f231d677543" name="a1da29874dd75caeb07dc2f231d677543"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Empty</b> ()</td></tr>
<tr class="memdesc:a1da29874dd75caeb07dc2f231d677543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the queue is empty, else returns false. <br /></td></tr>
<tr class="separator:a1da29874dd75caeb07dc2f231d677543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90762d90d93f813aa0db2d7e87d2b601" id="r_a90762d90d93f813aa0db2d7e87d2b601"><td class="memItemLeft" align="right" valign="top"><a id="a90762d90d93f813aa0db2d7e87d2b601" name="a90762d90d93f813aa0db2d7e87d2b601"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RandomShuffle</b> ()</td></tr>
<tr class="separator:a90762d90d93f813aa0db2d7e87d2b601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333e7c51318adea9227b9f5f1d1ac9a4" id="r_a333e7c51318adea9227b9f5f1d1ac9a4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a333e7c51318adea9227b9f5f1d1ac9a4">Copy</a> (std::deque&lt; _ValueType &gt; &amp;c)</td></tr>
<tr class="memdesc:a333e7c51318adea9227b9f5f1d1ac9a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the contents of the queue to <code>c</code>.  <br /></td></tr>
<tr class="separator:a333e7c51318adea9227b9f5f1d1ac9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb6a040da7bfbfeb31d24c7c63ff40b" id="r_a0fb6a040da7bfbfeb31d24c7c63ff40b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fb6a040da7bfbfeb31d24c7c63ff40b">Swap</a> (std::deque&lt; _ValueType &gt; &amp;c)</td></tr>
<tr class="memdesc:a0fb6a040da7bfbfeb31d24c7c63ff40b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member is a simple optimization for fetching the contents of the queue.  <br /></td></tr>
<tr class="separator:a0fb6a040da7bfbfeb31d24c7c63ff40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aeceed55c52f682f433c2d9de4a0d86ae" id="r_aeceed55c52f682f433c2d9de4a0d86ae"><td class="memItemLeft" align="right" valign="top"><a id="aeceed55c52f682f433c2d9de4a0d86ae" name="aeceed55c52f682f433c2d9de4a0d86ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Lock</b> ()</td></tr>
<tr class="separator:aeceed55c52f682f433c2d9de4a0d86ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1ca9421bc364da9eaed0b2a791ce33" id="r_a8d1ca9421bc364da9eaed0b2a791ce33"><td class="memItemLeft" align="right" valign="top"><a id="a8d1ca9421bc364da9eaed0b2a791ce33" name="a8d1ca9421bc364da9eaed0b2a791ce33"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Unlock</b> ()</td></tr>
<tr class="separator:a8d1ca9421bc364da9eaed0b2a791ce33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aac23af4787dbeaa55af2d3d3fa76f540" id="r_aac23af4787dbeaa55af2d3d3fa76f540"><td class="memItemLeft" align="right" valign="top"><a id="aac23af4787dbeaa55af2d3d3fa76f540" name="aac23af4787dbeaa55af2d3d3fa76f540"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>_maxLength</b></td></tr>
<tr class="separator:aac23af4787dbeaa55af2d3d3fa76f540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fcef37fe0964fc04548b8289be08b6" id="r_aa2fcef37fe0964fc04548b8289be08b6"><td class="memItemLeft" align="right" valign="top"><a id="aa2fcef37fe0964fc04548b8289be08b6" name="aa2fcef37fe0964fc04548b8289be08b6"></a>
std::deque&lt; _ValueType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_queue</b></td></tr>
<tr class="separator:aa2fcef37fe0964fc04548b8289be08b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4526a93d476e050d0c7e6ec1310f5c" id="r_abb4526a93d476e050d0c7e6ec1310f5c"><td class="memItemLeft" align="right" valign="top"><a id="abb4526a93d476e050d0c7e6ec1310f5c" name="abb4526a93d476e050d0c7e6ec1310f5c"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>_mutex</b></td></tr>
<tr class="separator:abb4526a93d476e050d0c7e6ec1310f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d81fff2f4a6147be9c268100541db7" id="r_a97d81fff2f4a6147be9c268100541db7"><td class="memItemLeft" align="right" valign="top"><a id="a97d81fff2f4a6147be9c268100541db7" name="a97d81fff2f4a6147be9c268100541db7"></a>
std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_signalled</b></td></tr>
<tr class="separator:a97d81fff2f4a6147be9c268100541db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bdd245c7c6b3727a238d073533992bf" id="r_a4bdd245c7c6b3727a238d073533992bf"><td class="memItemLeft" align="right" valign="top"><a id="a4bdd245c7c6b3727a238d073533992bf" name="a4bdd245c7c6b3727a238d073533992bf"></a>
std::unique_lock&lt; std::mutex &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_lock</b></td></tr>
<tr class="separator:a4bdd245c7c6b3727a238d073533992bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae599db2f5f686aad0fe4e4f25be38a27" id="r_ae599db2f5f686aad0fe4e4f25be38a27"><td class="memItemLeft" align="right" valign="top"><a id="ae599db2f5f686aad0fe4e4f25be38a27" name="ae599db2f5f686aad0fe4e4f25be38a27"></a>
std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><b>_cv</b></td></tr>
<tr class="separator:ae599db2f5f686aad0fe4e4f25be38a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename _ValueType&gt;<br />
class Dwm::Thread::Queue&lt; _ValueType &gt;</div><p>This template provides inter-thread first-in first-out (FIFO) queueing. </p>
<p>A source thread may insert objects into the back of the queue using <a class="el" href="#ab299aa8a99b55ca3d8060318b3929cd3" title="Inserts value on the back of the queue.">PushBack()</a> while a sink thread pops objects from the front of the queue using <a class="el" href="#ab2e201afc119ed280ad25760b65ffedb" title="Pops the entry from the front of the queue and stores it in value.">PopFront()</a>. A sink thread may use <a class="el" href="#a67e9203f20d26df3ed6f8722aff22eb1" title="Blocks the calling thread until the queue contains at least one entry.">WaitForNotEmpty()</a> to wait for entries to be added to the queue; the calling thread will be blocked until the queue is non-empty. A sink thread may also choose to use <a class="el" href="#a69b401fa39361443175d566b0c738319" title="Waits for the condition variable to be signalled or broadcasted.">ConditionWait()</a> and <a class="el" href="#ab2e201afc119ed280ad25760b65ffedb" title="Pops the entry from the front of the queue and stores it in value.">PopFront()</a>, which allows a source to wake up the sink using ConditionBroadcast() or <a class="el" href="#af1576afd114e7acc61cc7bed18f9471e" title="Unblocks at least one thread waiting on the condition variable.">ConditionSignal()</a> without pushing an entry into the queue. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a52812a90c5f415aa1ed6c37823a29947" name="a52812a90c5f415aa1ed6c37823a29947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52812a90c5f415aa1ed6c37823a29947">&#9670;&#160;</a></span>ConditionTimedWait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ValueType &gt; </div>
<div class="memtemplate">
template&lt;class Rep , class Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDwm_1_1Thread_1_1Queue.html">Dwm::Thread::Queue</a>&lt; _ValueType &gt;::ConditionTimedWait </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>timeToWait</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits for the condition variable to be signalled or broadcasted for timeToWait to pass. </p>
<p>Returns true if the condition variable was signalled or broadcasted, else returns false. </p>

</div>
</div>
<a id="a333e7c51318adea9227b9f5f1d1ac9a4" name="a333e7c51318adea9227b9f5f1d1ac9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333e7c51318adea9227b9f5f1d1ac9a4">&#9670;&#160;</a></span>Copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classDwm_1_1Thread_1_1Queue.html">Dwm::Thread::Queue</a>&lt; _ValueType &gt;::Copy </td>
          <td>(</td>
          <td class="paramtype">std::deque&lt; _ValueType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the contents of the queue to <code>c</code>. </p>
<p>Returns the number of elements copied. Note that <code>c</code> will always be cleared before elements are copied. Hence if there are no entries in the queue, <code>c</code> will be empty on return. </p>

</div>
</div>
<a id="a82cc337977e16ddc981b44ca2c2176b9" name="a82cc337977e16ddc981b44ca2c2176b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82cc337977e16ddc981b44ca2c2176b9">&#9670;&#160;</a></span>MaxLength() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classDwm_1_1Thread_1_1Queue.html">Dwm::Thread::Queue</a>&lt; _ValueType &gt;::MaxLength </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the max length of the queue. </p>
<p>If 0, no maximum length will be enforced. </p>

</div>
</div>
<a id="a401c683ee984e86844e0a1911df5c7a3" name="a401c683ee984e86844e0a1911df5c7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a401c683ee984e86844e0a1911df5c7a3">&#9670;&#160;</a></span>MaxLength() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classDwm_1_1Thread_1_1Queue.html">Dwm::Thread::Queue</a>&lt; _ValueType &gt;::MaxLength </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>maxLength</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets and returns the max length of the queue. </p>
<p>If 0, no maximum length will be enforced. </p>

</div>
</div>
<a id="a64b1293f4022a52dcd07955477f1bbbb" name="a64b1293f4022a52dcd07955477f1bbbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b1293f4022a52dcd07955477f1bbbb">&#9670;&#160;</a></span>PopBack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDwm_1_1Thread_1_1Queue.html">Dwm::Thread::Queue</a>&lt; _ValueType &gt;::PopBack </td>
          <td>(</td>
          <td class="paramtype">_ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pops the entry from the back of the queue and stores it in <code>value</code>. </p>
<p>Returns true on success, false on failure. </p>

</div>
</div>
<a id="ab2e201afc119ed280ad25760b65ffedb" name="ab2e201afc119ed280ad25760b65ffedb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e201afc119ed280ad25760b65ffedb">&#9670;&#160;</a></span>PopFront()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDwm_1_1Thread_1_1Queue.html">Dwm::Thread::Queue</a>&lt; _ValueType &gt;::PopFront </td>
          <td>(</td>
          <td class="paramtype">_ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pops the entry from the front of the queue and stores it in <code>value</code>. </p>
<p>Returns true on success, false on failure. </p>

</div>
</div>
<a id="a545b4b17f7ffadeec717e66a3a73bef0" name="a545b4b17f7ffadeec717e66a3a73bef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a545b4b17f7ffadeec717e66a3a73bef0">&#9670;&#160;</a></span>PushBack() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDwm_1_1Thread_1_1Queue.html">Dwm::Thread::Queue</a>&lt; _ValueType &gt;::PushBack </td>
          <td>(</td>
          <td class="paramtype">_ValueType &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts <code>value</code> on the back of the queue. </p>
<p>Returns true on success, false on failure. </p>

</div>
</div>
<a id="ab299aa8a99b55ca3d8060318b3929cd3" name="ab299aa8a99b55ca3d8060318b3929cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab299aa8a99b55ca3d8060318b3929cd3">&#9670;&#160;</a></span>PushBack() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDwm_1_1Thread_1_1Queue.html">Dwm::Thread::Queue</a>&lt; _ValueType &gt;::PushBack </td>
          <td>(</td>
          <td class="paramtype">const _ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts <code>value</code> on the back of the queue. </p>
<p>Returns true on success, false on failure. </p>

</div>
</div>
<a id="a0745cdf8d3b529ca3bb01c5340b394e5" name="a0745cdf8d3b529ca3bb01c5340b394e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0745cdf8d3b529ca3bb01c5340b394e5">&#9670;&#160;</a></span>PushBack() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ValueType &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classDwm_1_1Thread_1_1Queue.html">Dwm::Thread::Queue</a>&lt; _ValueType &gt;::PushBack </td>
          <td>(</td>
          <td class="paramtype">InputIterator</td>          <td class="paramname"><span class="paramname"><em>firstIter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator</td>          <td class="paramname"><span class="paramname"><em>lastIter</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the values from firstIter to lastIter on the back of the queue. </p>
<p>Note that lastIter is excluded, i.e. the range of entries inserted is [firstIter,lastIter). Returns the number of entries inserted. </p>

</div>
</div>
<a id="ab9097a3aaf8a60e73dbbe92d6398a66a" name="ab9097a3aaf8a60e73dbbe92d6398a66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9097a3aaf8a60e73dbbe92d6398a66a">&#9670;&#160;</a></span>PushFront()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDwm_1_1Thread_1_1Queue.html">Dwm::Thread::Queue</a>&lt; _ValueType &gt;::PushFront </td>
          <td>(</td>
          <td class="paramtype">const _ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts <code>value</code> on the front of the queue. </p>
<p>Returns true on success, false on failure. </p>

</div>
</div>
<a id="a0fb6a040da7bfbfeb31d24c7c63ff40b" name="a0fb6a040da7bfbfeb31d24c7c63ff40b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb6a040da7bfbfeb31d24c7c63ff40b">&#9670;&#160;</a></span>Swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classDwm_1_1Thread_1_1Queue.html">Dwm::Thread::Queue</a>&lt; _ValueType &gt;::Swap </td>
          <td>(</td>
          <td class="paramtype">std::deque&lt; _ValueType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This member is a simple optimization for fetching the contents of the queue. </p>
<p>It swaps the encapsulated queue with <code>c</code>, then clears the contents of the encapsulated queue. It returns the number of entries in <code>c</code> after the swap, i.e. the number of entries that were in the encapsulated queue before this member was called. </p>

</div>
</div>
<a id="afba47d22548f5b720af4ed663c9d3803" name="afba47d22548f5b720af4ed663c9d3803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba47d22548f5b720af4ed663c9d3803">&#9670;&#160;</a></span>TimedWaitForNotEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ValueType &gt; </div>
<div class="memtemplate">
template&lt;class Rep , class Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDwm_1_1Thread_1_1Queue.html">Dwm::Thread::Queue</a>&lt; _ValueType &gt;::TimedWaitForNotEmpty </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>timeToWait</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits <code>timeToWait</code> for the queue to be non-empty. </p>
<p>Returns true if the queue is non-empty, else returns false. </p>

</div>
</div>
<a id="a67e9203f20d26df3ed6f8722aff22eb1" name="a67e9203f20d26df3ed6f8722aff22eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e9203f20d26df3ed6f8722aff22eb1">&#9670;&#160;</a></span>WaitForNotEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDwm_1_1Thread_1_1Queue.html">Dwm::Thread::Queue</a>&lt; _ValueType &gt;::WaitForNotEmpty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks the calling thread until the queue contains at least one entry. </p>
<p>Returns true on success, false on failure. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="DwmThreadQueue_8hh_source.html">DwmThreadQueue.hh</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>Dwm</b></li><li class="navelem"><b>Thread</b></li><li class="navelem"><a class="el" href="classDwm_1_1Thread_1_1Queue.html">Queue</a></li>
    <li class="footer">
      <table>
	<tr>
	  <td valign="bottom" align="right">
	    <address class="footer">
	      dwm
	    </address>
	  </td>
	</tr>
      </table>
    </li>
  </ul>
</div>
</body>
</html>
