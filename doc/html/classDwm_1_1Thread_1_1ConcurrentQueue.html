<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<title>libDwm-0.0.20240716: Dwm::Thread::ConcurrentQueue&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width=100%>
 <tbody>
 <tr style="height: 56px;">
  <td>&nbsp;</td>
  <td id="projectlogo">&nbsp;<img alt="Logo" src="libDwm_blue_base.svg" height=40 align="left" style="vertical-align: top;"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libDwm-0.0.20240716
   </div>
  </td>
  <td><a href="http://www.mcplex.net"><img src="mcplex_net_blue_shadowed.svg" height=35 align="right" style="vertical-align: bottom;"></a></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',true);
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classDwm_1_1Thread_1_1ConcurrentQueue.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classDwm_1_1Thread_1_1ConcurrentQueue-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Dwm::Thread::ConcurrentQueue&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Concurrent queue template.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="DwmConcurrentQueue_8hh_source.html">DwmConcurrentQueue.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a873b6b00b360a2bcd63fa2e72c1854ce" id="r_a873b6b00b360a2bcd63fa2e72c1854ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a873b6b00b360a2bcd63fa2e72c1854ce">ConcurrentQueue</a> (uint64_t maxLength=10000, useconds_t pushSleepUsecs=1000)</td></tr>
<tr class="memdesc:a873b6b00b360a2bcd63fa2e72c1854ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a873b6b00b360a2bcd63fa2e72c1854ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0023f301cbb0e967a8a0b40af1f79b28" id="r_a0023f301cbb0e967a8a0b40af1f79b28"><td class="memItemLeft" align="right" valign="top"><a id="a0023f301cbb0e967a8a0b40af1f79b28" name="a0023f301cbb0e967a8a0b40af1f79b28"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~ConcurrentQueue</b> ()</td></tr>
<tr class="memdesc:a0023f301cbb0e967a8a0b40af1f79b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. Walks the queue and deletes all entries. <br /></td></tr>
<tr class="separator:a0023f301cbb0e967a8a0b40af1f79b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302e27db22c94e04396c6c37956b8e24" id="r_a302e27db22c94e04396c6c37956b8e24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a302e27db22c94e04396c6c37956b8e24">PopFront</a> (T &amp;result)</td></tr>
<tr class="memdesc:a302e27db22c94e04396c6c37956b8e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the queue is not empty, pops the front entry into <code>result</code> and returns true.  <br /></td></tr>
<tr class="separator:a302e27db22c94e04396c6c37956b8e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6712a3d19393b67d423bde0bd175e1d0" id="r_a6712a3d19393b67d423bde0bd175e1d0"><td class="memItemLeft" align="right" valign="top"><a id="a6712a3d19393b67d423bde0bd175e1d0" name="a6712a3d19393b67d423bde0bd175e1d0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>PopFront</b> (std::vector&lt; T &gt; &amp;result)</td></tr>
<tr class="separator:a6712a3d19393b67d423bde0bd175e1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f1b0f6ff6ca6080f079fbbedfa2b66" id="r_a97f1b0f6ff6ca6080f079fbbedfa2b66"><td class="memItemLeft" align="right" valign="top"><a id="a97f1b0f6ff6ca6080f079fbbedfa2b66" name="a97f1b0f6ff6ca6080f079fbbedfa2b66"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>PushBack</b> (const T &amp;t)</td></tr>
<tr class="memdesc:a97f1b0f6ff6ca6080f079fbbedfa2b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the queue to not be full (see the <a class="el" href="classDwm_1_1Thread_1_1Queue.html" title="This template provides inter-thread first-in first-out (FIFO) queueing.">Queue</a> constructor), then pushes <code>t</code> onto the back of the queue and returns true. <br /></td></tr>
<tr class="separator:a97f1b0f6ff6ca6080f079fbbedfa2b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15acd5f321a938f9c8621b2887577cf5" id="r_a15acd5f321a938f9c8621b2887577cf5"><td class="memItemLeft" align="right" valign="top"><a id="a15acd5f321a938f9c8621b2887577cf5" name="a15acd5f321a938f9c8621b2887577cf5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>PushBack</b> (const std::vector&lt; T &gt; &amp;t)</td></tr>
<tr class="separator:a15acd5f321a938f9c8621b2887577cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class Dwm::Thread::ConcurrentQueue&lt; T &gt;</div><p>Concurrent queue template. </p>
<p>This is based on an old article from Herb Sutter in Dr. Dobb's Journal, with modifications to support pushing and popping more than one entry at a time and reduction of the number of pointers.</p>
<p>The operations here are not wait-free, but I've tried to minimize contention. There is no contention between a producer (caller of <a class="el" href="#a97f1b0f6ff6ca6080f079fbbedfa2b66" title="Waits for the queue to not be full (see the Queue constructor), then pushes t onto the back of the qu...">PushBack()</a>) and a consumer (caller of <a class="el" href="#a302e27db22c94e04396c6c37956b8e24" title="If the queue is not empty, pops the front entry into result and returns true.">PopFront()</a>). Short periods of contention will exist among producers. Short periods of contention will exist among consumers.</p>
<p>In my typical use, I only have one producer and one consumer per <a class="el" href="classDwm_1_1Thread_1_1Queue.html" title="This template provides inter-thread first-in first-out (FIFO) queueing.">Queue</a>. Occasionally I have the need for one producer and multiple consumers (for example, one producer feeding 'work' to multiple 'worker' threads). I rarely have a need for a single queue with multiple producers. If I need multiple producers, I almost always need (or want) multiple consumers. In those cases it almost always makes sense to have multiple queues, each with a single producer and a single consumer. For multiple wait-free producers, you've already thrown out the notion of ordered processing since you're not synchronizing the producers (else they'd be waiting for synchronization points). In most such cases, the solution with the most concurrency is multiple queues.</p>
<p>Of course there are exceptions. For example, you might want one producer to feed a set of consumers who then act as producers to feed one consumer (break a problem apart for multiple worker threads, then put it back together with a single consumer thread). But again, you've already thrown out strict ordering; that final consumer might as well be reading from multiple queues. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a873b6b00b360a2bcd63fa2e72c1854ce" name="a873b6b00b360a2bcd63fa2e72c1854ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873b6b00b360a2bcd63fa2e72c1854ce">&#9670;&#160;</a></span>ConcurrentQueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDwm_1_1Thread_1_1ConcurrentQueue.html">Dwm::Thread::ConcurrentQueue</a>&lt; T &gt;::ConcurrentQueue </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>maxLength</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10000</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">useconds_t</td>          <td class="paramname"><span class="paramname"><em>pushSleepUsecs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p><code>maxLength</code> is the maximum depth of the queue. When the queue reaches this depth, we will sleep <code>pushSleepUsecs</code> at a time until the queue is shallower than <code>maxLength</code>. This allows a consuming thread to catch up with <a class="el" href="#a302e27db22c94e04396c6c37956b8e24" title="If the queue is not empty, pops the front entry into result and returns true.">PopFront()</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a302e27db22c94e04396c6c37956b8e24" name="a302e27db22c94e04396c6c37956b8e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302e27db22c94e04396c6c37956b8e24">&#9670;&#160;</a></span>PopFront()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDwm_1_1Thread_1_1ConcurrentQueue.html">Dwm::Thread::ConcurrentQueue</a>&lt; T &gt;::PopFront </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the queue is not empty, pops the front entry into <code>result</code> and returns true. </p>
<p>If the queue is empty, returns false. A caller may choose to sleep a short period of time when false is returned. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="DwmConcurrentQueue_8hh_source.html">DwmConcurrentQueue.hh</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>Dwm</b></li><li class="navelem"><b>Thread</b></li><li class="navelem"><a class="el" href="classDwm_1_1Thread_1_1ConcurrentQueue.html">ConcurrentQueue</a></li>
    <li class="footer">
      <table>
	<tr>
	  <td valign="bottom" align="right">
	    <address class="footer">
	      dwm
	    </address>
	  </td>
	</tr>
      </table>
    </li>
  </ul>
</div>
</body>
</html>
