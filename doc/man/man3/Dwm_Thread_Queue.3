.TH "Dwm::Thread::Queue< _ValueType >" 3 "libDwm-0.0.20240716" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Dwm::Thread::Queue< _ValueType > \- This template provides inter-thread first-in first-out (FIFO) queueing\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <DwmThreadQueue\&.hh>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBQueue\fP ()"
.br
.RI "Constructor\&. "
.ti -1c
.RI "\fB~Queue\fP ()"
.br
.RI "Destructor\&. "
.ti -1c
.RI "uint32_t \fBMaxLength\fP () const"
.br
.RI "Returns the max length of the queue\&. "
.ti -1c
.RI "uint32_t \fBMaxLength\fP (uint32_t maxLength)"
.br
.RI "Sets and returns the max length of the queue\&. "
.ti -1c
.RI "std::deque< _ValueType >::size_type \fBLength\fP () const"
.br
.RI "Returns the current length of the queue\&. "
.ti -1c
.RI "bool \fBPushBack\fP (const _ValueType &value)"
.br
.RI "Inserts \fRvalue\fP on the back of the queue\&. "
.ti -1c
.RI "bool \fBPushBack\fP (_ValueType &&value)"
.br
.RI "Inserts \fRvalue\fP on the back of the queue\&. "
.ti -1c
.RI "template<typename InputIterator > uint32_t \fBPushBack\fP (InputIterator firstIter, InputIterator lastIter)"
.br
.RI "Inserts the values from firstIter to lastIter on the back of the queue\&. "
.ti -1c
.RI "bool \fBPushFront\fP (const _ValueType &value)"
.br
.RI "Inserts \fRvalue\fP on the front of the queue\&. "
.ti -1c
.RI "template<typename InputIterator > uint32_t \fBPushFront\fP (InputIterator firstIter, InputIterator lastIter)"
.br
.ti -1c
.RI "void \fBConditionSignal\fP ()"
.br
.RI "Unblocks at least one thread waiting on the condition variable\&. "
.ti -1c
.RI "bool \fBConditionWait\fP ()"
.br
.RI "Waits for the condition variable to be signalled or broadcasted\&. "
.ti -1c
.RI "template<class Rep , class Period > bool \fBConditionTimedWait\fP (const std::chrono::duration< Rep, Period > &timeToWait)"
.br
.RI "Waits for the condition variable to be signalled or broadcasted for timeToWait to pass\&. "
.ti -1c
.RI "bool \fBPopFront\fP (_ValueType &value)"
.br
.RI "Pops the entry from the front of the queue and stores it in \fRvalue\fP\&. "
.ti -1c
.RI "bool \fBPopBack\fP (_ValueType &value)"
.br
.RI "Pops the entry from the back of the queue and stores it in \fRvalue\fP\&. "
.ti -1c
.RI "bool \fBWaitForNotEmpty\fP ()"
.br
.RI "Blocks the calling thread until the queue contains at least one entry\&. "
.ti -1c
.RI "template<class Rep , class Period > bool \fBTimedWaitForNotEmpty\fP (const std::chrono::duration< Rep, Period > &timeToWait)"
.br
.RI "Waits \fRtimeToWait\fP for the queue to be non-empty\&. "
.ti -1c
.RI "bool \fBEmpty\fP ()"
.br
.RI "Returns true if the queue is empty, else returns false\&. "
.ti -1c
.RI "void \fBRandomShuffle\fP ()"
.br
.ti -1c
.RI "uint32_t \fBCopy\fP (std::deque< _ValueType > &c)"
.br
.RI "Copies the contents of the queue to \fRc\fP\&. "
.ti -1c
.RI "uint32_t \fBSwap\fP (std::deque< _ValueType > &c)"
.br
.RI "This member is a simple optimization for fetching the contents of the queue\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBLock\fP ()"
.br
.ti -1c
.RI "void \fBUnlock\fP ()"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "uint32_t \fB_maxLength\fP"
.br
.ti -1c
.RI "std::deque< _ValueType > \fB_queue\fP"
.br
.ti -1c
.RI "std::mutex \fB_mutex\fP"
.br
.ti -1c
.RI "std::atomic< bool > \fB_signalled\fP"
.br
.ti -1c
.RI "std::unique_lock< std::mutex > \fB_lock\fP"
.br
.ti -1c
.RI "std::condition_variable \fB_cv\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _ValueType>
.br
class Dwm::Thread::Queue< _ValueType >"This template provides inter-thread first-in first-out (FIFO) queueing\&. 

A source thread may insert objects into the back of the queue using \fBPushBack()\fP while a sink thread pops objects from the front of the queue using \fBPopFront()\fP\&. A sink thread may use \fBWaitForNotEmpty()\fP to wait for entries to be added to the queue; the calling thread will be blocked until the queue is non-empty\&. A sink thread may also choose to use \fBConditionWait()\fP and \fBPopFront()\fP, which allows a source to wake up the sink using ConditionBroadcast() or \fBConditionSignal()\fP without pushing an entry into the queue\&. 
.SH "Member Function Documentation"
.PP 
.SS "template<typename _ValueType > template<class Rep , class Period > bool \fBDwm::Thread::Queue\fP< _ValueType >::ConditionTimedWait (const std::chrono::duration< Rep, Period > & timeToWait)\fR [inline]\fP"

.PP
Waits for the condition variable to be signalled or broadcasted for timeToWait to pass\&. Returns true if the condition variable was signalled or broadcasted, else returns false\&. 
.SS "template<typename _ValueType > uint32_t \fBDwm::Thread::Queue\fP< _ValueType >::Copy (std::deque< _ValueType > & c)\fR [inline]\fP"

.PP
Copies the contents of the queue to \fRc\fP\&. Returns the number of elements copied\&. Note that \fRc\fP will always be cleared before elements are copied\&. Hence if there are no entries in the queue, \fRc\fP will be empty on return\&. 
.SS "template<typename _ValueType > uint32_t \fBDwm::Thread::Queue\fP< _ValueType >::MaxLength () const\fR [inline]\fP"

.PP
Returns the max length of the queue\&. If 0, no maximum length will be enforced\&. 
.SS "template<typename _ValueType > uint32_t \fBDwm::Thread::Queue\fP< _ValueType >::MaxLength (uint32_t maxLength)\fR [inline]\fP"

.PP
Sets and returns the max length of the queue\&. If 0, no maximum length will be enforced\&. 
.SS "template<typename _ValueType > bool \fBDwm::Thread::Queue\fP< _ValueType >::PopBack (_ValueType & value)\fR [inline]\fP"

.PP
Pops the entry from the back of the queue and stores it in \fRvalue\fP\&. Returns true on success, false on failure\&. 
.SS "template<typename _ValueType > bool \fBDwm::Thread::Queue\fP< _ValueType >::PopFront (_ValueType & value)\fR [inline]\fP"

.PP
Pops the entry from the front of the queue and stores it in \fRvalue\fP\&. Returns true on success, false on failure\&. 
.SS "template<typename _ValueType > bool \fBDwm::Thread::Queue\fP< _ValueType >::PushBack (_ValueType && value)\fR [inline]\fP"

.PP
Inserts \fRvalue\fP on the back of the queue\&. Returns true on success, false on failure\&. 
.SS "template<typename _ValueType > bool \fBDwm::Thread::Queue\fP< _ValueType >::PushBack (const _ValueType & value)\fR [inline]\fP"

.PP
Inserts \fRvalue\fP on the back of the queue\&. Returns true on success, false on failure\&. 
.SS "template<typename _ValueType > template<typename InputIterator > uint32_t \fBDwm::Thread::Queue\fP< _ValueType >::PushBack (InputIterator firstIter, InputIterator lastIter)\fR [inline]\fP"

.PP
Inserts the values from firstIter to lastIter on the back of the queue\&. Note that lastIter is excluded, i\&.e\&. the range of entries inserted is [firstIter,lastIter)\&. Returns the number of entries inserted\&. 
.SS "template<typename _ValueType > bool \fBDwm::Thread::Queue\fP< _ValueType >::PushFront (const _ValueType & value)\fR [inline]\fP"

.PP
Inserts \fRvalue\fP on the front of the queue\&. Returns true on success, false on failure\&. 
.SS "template<typename _ValueType > uint32_t \fBDwm::Thread::Queue\fP< _ValueType >::Swap (std::deque< _ValueType > & c)\fR [inline]\fP"

.PP
This member is a simple optimization for fetching the contents of the queue\&. It swaps the encapsulated queue with \fRc\fP, then clears the contents of the encapsulated queue\&. It returns the number of entries in \fRc\fP after the swap, i\&.e\&. the number of entries that were in the encapsulated queue before this member was called\&. 
.SS "template<typename _ValueType > template<class Rep , class Period > bool \fBDwm::Thread::Queue\fP< _ValueType >::TimedWaitForNotEmpty (const std::chrono::duration< Rep, Period > & timeToWait)\fR [inline]\fP"

.PP
Waits \fRtimeToWait\fP for the queue to be non-empty\&. Returns true if the queue is non-empty, else returns false\&. 
.SS "template<typename _ValueType > bool \fBDwm::Thread::Queue\fP< _ValueType >::WaitForNotEmpty ()\fR [inline]\fP"

.PP
Blocks the calling thread until the queue contains at least one entry\&. Returns true on success, false on failure\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for libDwm-0\&.0\&.20240716 from the source code\&.
