.TH "Dwm::Ipv4Routes< _valueT >" 3 "libDwm-0.0.20240716" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Dwm::Ipv4Routes< _valueT > \- This template class provides an associative container keyed by IPv4 addresses, with longest-match searching\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <DwmIpv4Routes\&.hh>\fP
.PP
Inherits \fBDwm::DescriptorIOCapable\fP, Dwm::FileIOCapable, \fBDwm::StreamIOCapable\fP, \fBDwm::StreamedLengthCapable\fP, \fBDwm::GZIOCapable\fP, and \fBDwm::BZ2IOCapable\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef std::unordered_map< \fBIpv4Address\fP, _valueT, OurIpv4AddressHash > \fB_RepSubType\fP"
.br
.ti -1c
.RI "typedef _RepSubType::const_iterator \fBconst_iterator\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBIpv4Routes\fP ()"
.br
.RI "Constructor\&. "
.ti -1c
.RI "void \fBClear\fP ()"
.br
.RI "Clears all entries\&. "
.ti -1c
.RI "bool \fBEmpty\fP () const"
.br
.RI "Returns true if there are no entries\&. "
.ti -1c
.RI "bool \fBAdd\fP (const \fBIpv4Prefix\fP &prefix, const _valueT &value)"
.br
.RI "Adds an entry\&. "
.ti -1c
.RI "void \fBAdd\fP (const \fBIpv4Routes\fP< _valueT > &routes)"
.br
.RI "Bulk add all \fRroutes\fP\&. Note this will overwrite existing routes\&. "
.ti -1c
.RI "_valueT & \fBoperator[]\fP (const \fBIpv4Prefix\fP &prefix)"
.br
.RI "operator [] works like you would expect from an STL map\&. "
.ti -1c
.RI "bool \fBDelete\fP (const \fBIpv4Prefix\fP &prefix)"
.br
.RI "Deletes the entry for \fRprefix\fP\&. "
.ti -1c
.RI "bool \fBFind\fP (const \fBIpv4Prefix\fP &prefix, _valueT &match) const"
.br
.RI "Find the entry for the given \fRprefix\fP\&. "
.ti -1c
.RI "void \fBFindInSubMap\fP (const _RepSubType &subMap, \fBIpv4Address\fP ipAddr, std::pair< bool, _valueT > &result) const"
.br
.ti -1c
.RI "bool \fBNewFindLongest\fP (const \fBIpv4Address\fP &ipAddr, std::pair< \fBIpv4Prefix\fP, _valueT > &match) const"
.br
.ti -1c
.RI "bool \fBFindLongest\fP (const \fBIpv4Address\fP &ipAddr, std::pair< \fBIpv4Prefix\fP, _valueT > &match) const"
.br
.RI "Finds the longest match for \fRipAddr\fP\&. "
.ti -1c
.RI "bool \fBFindLongest\fP (const \fBIpv4Address\fP &ipAddr, std::pair< \fBIpv4Prefix\fP, const _valueT * > &match) const"
.br
.RI "Finds the longest match for \fRipAddr\fP\&. "
.ti -1c
.RI "bool \fBFind\fP (const \fBIpv4Address\fP &ipAddr, std::vector< std::pair< \fBIpv4Prefix\fP, _valueT > > &matches) const"
.br
.RI "Finds all matches for \fRipAddr\fP\&. "
.ti -1c
.RI "void \fBMaxLoadFactor\fP (float loadFactor)"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBIpv4Routes\fP< _valueT > &r) const"
.br
.RI "operator == It's unlikely you'd ever need to use this, and it's expensive\&. "
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBIpv4Routes\fP< _valueT > &r) const"
.br
.RI "operator != It's unlikely you'd ever need to use this, and it's expensive\&. "
.ti -1c
.RI "uint32_t \fBSize\fP () const"
.br
.RI "Returns the number of routes\&. "
.ti -1c
.RI "void \fBHashSizes\fP (std::vector< std::pair< uint8_t, uint32_t > > &sizes) const"
.br
.ti -1c
.RI "uint64_t \fBStreamedLength\fP () const override"
.br
.RI "Return the number of bytes that would be written if the object's Write(ostream &), Write(FILE *) or Write(int) member were called\&. "
.ti -1c
.RI "std::istream & \fBRead\fP (std::istream &is) override"
.br
.RI "Reads the routes from an istream\&. Returns the istream\&. "
.ti -1c
.RI "std::ostream & \fBWrite\fP (std::ostream &os) const override"
.br
.RI "Writes the routes to an ostream\&. Returns the ostream\&. "
.ti -1c
.RI "size_t \fBRead\fP (FILE *f) override"
.br
.RI "Reades the routes from a FILE pointer\&. "
.ti -1c
.RI "size_t \fBWrite\fP (FILE *f) const override"
.br
.RI "Writes the routes to a FILE pointer\&. "
.ti -1c
.RI "ssize_t \fBRead\fP (int fd) override"
.br
.RI "Reads the routes from a file descriptor\&. "
.ti -1c
.RI "ssize_t \fBWrite\fP (int fd) const override"
.br
.RI "Writes the routes to a file descriptor\&. "
.ti -1c
.RI "int \fBRead\fP (gzFile gzf) override"
.br
.RI "Reads the routes from a gzFile\&. "
.ti -1c
.RI "int \fBWrite\fP (gzFile gzf) const override"
.br
.RI "Writes the routes to a gzFile\&. "
.ti -1c
.RI "int \fBBZRead\fP (BZFILE *bzf) override"
.br
.RI "Reads the routes from a BZFILE pointer\&. "
.ti -1c
.RI "int \fBBZWrite\fP (BZFILE *bzf) const override"
.br
.RI "Writes the routes to a BZFILE pointer\&. "
.ti -1c
.RI "template<typename BinaryPredicate > void \fBCoalesce\fP (BinaryPredicate pred)"
.br
.RI "Combines adjacent prefixes that can be combined (same value and prefixes can be represented by a prefix with a mask length one bit wider), then removes specific prefixes that are covered by a wider prefix with the same value\&. "
.ti -1c
.RI "void \fBCoalesce\fP ()"
.br
.ti -1c
.RI "void \fBGetAllKeys\fP (std::vector< \fBIpv4Prefix\fP > &keys) const"
.br
.ti -1c
.RI "void \fBSortByKey\fP (std::vector< std::pair< \fBIpv4Prefix\fP, _valueT > > &target, bool ascending=true) const"
.br
.ti -1c
.RI "void \fBSortByValue\fP (std::vector< std::pair< \fBIpv4Prefix\fP, _valueT > > &target)"
.br
.RI "Sorts the contained pair<Ipv4Prefix,_valueT> values into a vector, in descending order by the value stored for each prefix\&. "
.ti -1c
.RI "uint32_t \fBAddressesCovered\fP () const"
.br
.RI "Returns the number of addresses covered by the contained prefixes, not including 0/0\&. "
.ti -1c
.RI "const std::array< _RepSubType, 33 > & \fBHashMaps\fP () const"
.br
.RI "Returns a const reference to the contained hash maps\&. "
.in -1c

Public Member Functions inherited from \fBDwm::DescriptorReadable\fP
.in +1c
.ti -1c
.RI "virtual \fB~DescriptorReadable\fP ()"
.br
.RI "destructor "
.in -1c

Public Member Functions inherited from \fBDwm::DescriptorWritable\fP
.in +1c
.ti -1c
.RI "virtual \fB~DescriptorWritable\fP ()"
.br
.RI "Destructor\&. "
.in -1c

Public Member Functions inherited from \fBDwm::StreamReadable\fP
.in +1c
.ti -1c
.RI "virtual \fB~StreamReadable\fP ()"
.br
.RI "destructor "
.in -1c

Public Member Functions inherited from \fBDwm::StreamWritable\fP
.in +1c
.ti -1c
.RI "virtual \fB~StreamWritable\fP ()"
.br
.RI "Destructor\&. "
.in -1c

Public Member Functions inherited from \fBDwm::GZReadable\fP
.in +1c
.ti -1c
.RI "virtual \fB~GZReadable\fP ()"
.br
.RI "destructor "
.in -1c

Public Member Functions inherited from \fBDwm::GZWritable\fP
.in +1c
.ti -1c
.RI "virtual \fB~GZWritable\fP ()"
.br
.RI "destructor "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "template<typename BinaryPredicate > bool \fBHaveWiderMatch\fP (const \fBIpv4Address\fP &addr, uint8_t maskLen, const _valueT &val, BinaryPredicate pred) const"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "std::array< _RepSubType, 33 > \fB_hashMaps\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _valueT>
.br
class Dwm::Ipv4Routes< _valueT >"This template class provides an associative container keyed by IPv4 addresses, with longest-match searching\&. 

While this isn't as speedy to search as \fBPatricia\fP or radix, it is based on STL containers and is hence easy to understand and maintain (note how few lines of actual code are here)\&.
.PP
I/O functionality is provided, but the real work there is done in the \fBDwm::IO\fP class\&.
.SS "Performance"
I tested this class with a global IPv4 routing table from October 7, 2005\&. It contained 178,567 unique prefixes\&. The code was compiled with 'g++ -O2 \&.\&.\&.' and run on a Xeon 2\&.8GHz host running FreeBSD 5\&.3\&. Each test looked up one address from each of the 178,567 prefixes, and was run 10 times\&.
.PP
FindLongest(const Ipv4Address &, std::pair<Ipv4Prefix,_valueT> &)
.IP "\(bu" 2
yielded 830,000 lookups/sec with an Ipv4Routes<uint32_t>\&. Since this member copies into the value in the passed-in pair reference using operator =, it will be slower with larger _valueT types\&.
.PP
.PP
FindLongest(const Ipv4Address &, std::pair<Ipv4Prefix,_valueT *> &)
.IP "\(bu" 2
yielded 1,040,000 lookups/sec with an Ipv4Routes<string>\&. It makes sense to use this with larger _valueT types\&. I've no idea why it is faster than the previous \fBFindLongest()\fP function that copies by value; it should be just as cheap to copy a uint32_t as it is to copy a pointer\&.
.PP
.PP
In October 2007 I switched to using <unordered_map> for the internal containers\&. I set the max_load_factor to \&.15 and get 1,168,000 lookups/sec for Ipv4Routes<uint32_t> when calling FindLongest(const Ipv4Address &, std::pair<Ipv4Prefix,_valueT> &) and 1,489,081 lookups/sec with Ipv4Routes<string> when calling FindLongest(const Ipv4Address &, std::pair<Ipv4Prefix,_valueT *> &)
.PP
More current measurements in 2020 on a Threadripper 3960X: roughly 5\&.3 million lookups/second for Ipv4Routes<string>\&.
.PP
Note: I don't consider this code fast for lookups; it's a tradeoff\&. You can get \fImuch\fP faster lookups with sorted instances of std::vector, but at the expense of poor average insertion and deletion (and linear in the size of each vector in the worst-case)\&. On modern CPUs, cache-friendly containers like std::vector are a big advantage for lookups if you keep them sorted, but keeping them sorted is expensive\&. A quick hack using sorted std::vector and std::lower_bound yield about a 10X improvement in lookups but a severe penaly for insertions\&. This would be less true if the typical prefix length distribution was close to normal, but in the real world it's typically heavy-tailed with the peak between /22 and /24\&. 
.SH "Member Function Documentation"
.PP 
.SS "template<typename _valueT > bool \fBDwm::Ipv4Routes\fP< _valueT >::Add (const \fBIpv4Prefix\fP & prefix, const _valueT & value)\fR [inline]\fP"

.PP
Adds an entry\&. Returns false (and does nothing) if there was already an entry present for \fRprefix\fP\&. 
.SS "template<typename _valueT > int \fBDwm::Ipv4Routes\fP< _valueT >::BZRead (BZFILE * bzf)\fR [inline]\fP, \fR [override]\fP, \fR [virtual]\fP"

.PP
Reads the routes from a BZFILE pointer\&. Returns the number of bytes read on success, -1 on failure\&. 
.PP
Implements \fBDwm::BZ2Readable\fP\&.
.SS "template<typename _valueT > int \fBDwm::Ipv4Routes\fP< _valueT >::BZWrite (BZFILE * bzf) const\fR [inline]\fP, \fR [override]\fP, \fR [virtual]\fP"

.PP
Writes the routes to a BZFILE pointer\&. Returns the number of bytes written on success, -1 on failure\&. 
.PP
Implements \fBDwm::BZ2Writable\fP\&.
.SS "template<typename _valueT > template<typename BinaryPredicate > void \fBDwm::Ipv4Routes\fP< _valueT >::Coalesce (BinaryPredicate pred)\fR [inline]\fP"

.PP
Combines adjacent prefixes that can be combined (same value and prefixes can be represented by a prefix with a mask length one bit wider), then removes specific prefixes that are covered by a wider prefix with the same value\&. While we accept a predicate used to compare the two values, it only makes sense to use std::equal_to<_valueT>() or an equivalent since we make no guarantee of which of the two values we will use in the combined entry\&. 
.SS "template<typename _valueT > bool \fBDwm::Ipv4Routes\fP< _valueT >::Delete (const \fBIpv4Prefix\fP & prefix)\fR [inline]\fP"

.PP
Deletes the entry for \fRprefix\fP\&. Returns true on success, false if an entry wasn't found for \fRprefix\fP\&. 
.SS "template<typename _valueT > bool \fBDwm::Ipv4Routes\fP< _valueT >::Find (const \fBIpv4Address\fP & ipAddr, std::vector< std::pair< \fBIpv4Prefix\fP, _valueT > > & matches) const\fR [inline]\fP"

.PP
Finds all matches for \fRipAddr\fP\&. Places the results in \fRmatches\fP (in longest-match-first order) and returns true if any matches were found\&. Returns false if no matches were found\&. 
.SS "template<typename _valueT > bool \fBDwm::Ipv4Routes\fP< _valueT >::Find (const \fBIpv4Prefix\fP & prefix, _valueT & match) const\fR [inline]\fP"

.PP
Find the entry for the given \fRprefix\fP\&. If an entry is found, the value is stored in \fRmatch\fP and true is returned\&. Else false is returned\&. 
.SS "template<typename _valueT > bool \fBDwm::Ipv4Routes\fP< _valueT >::FindLongest (const \fBIpv4Address\fP & ipAddr, std::pair< \fBIpv4Prefix\fP, _valueT > & match) const\fR [inline]\fP"

.PP
Finds the longest match for \fRipAddr\fP\&. Places the result in \fRmatch\fP and returns true on success\&. Returns false if no match was found for \fRipAddr\fP\&. 
.SS "template<typename _valueT > bool \fBDwm::Ipv4Routes\fP< _valueT >::FindLongest (const \fBIpv4Address\fP & ipAddr, std::pair< \fBIpv4Prefix\fP, const _valueT * > & match) const\fR [inline]\fP"

.PP
Finds the longest match for \fRipAddr\fP\&. Places the result in \fRmatch\fP and returns true on success\&. Returns false if no match was found for \fRipAddr\fP\&. Note that match\&.second is a pointer to const for the value stored under the prefix\&. That means you need to be careful using this member; don't call free() or delete() on match\&.second\&. 
.SS "template<typename _valueT > bool \fBDwm::Ipv4Routes\fP< _valueT >::operator!= (const \fBIpv4Routes\fP< _valueT > & r) const\fR [inline]\fP"

.PP
operator != It's unlikely you'd ever need to use this, and it's expensive\&. It's mainly here for unit testing\&. 
.SS "template<typename _valueT > bool \fBDwm::Ipv4Routes\fP< _valueT >::operator== (const \fBIpv4Routes\fP< _valueT > & r) const\fR [inline]\fP"

.PP
operator == It's unlikely you'd ever need to use this, and it's expensive\&. It's mainly here for unit testing\&. 
.SS "template<typename _valueT > size_t \fBDwm::Ipv4Routes\fP< _valueT >::Read (FILE * f)\fR [inline]\fP, \fR [override]\fP, \fR [virtual]\fP"

.PP
Reades the routes from a FILE pointer\&. Returns 1 on success, 0 on failure\&. 
.PP
Implements \fBDwm::FileReadable\fP\&.
.SS "template<typename _valueT > int \fBDwm::Ipv4Routes\fP< _valueT >::Read (gzFile gzf)\fR [inline]\fP, \fR [override]\fP, \fR [virtual]\fP"

.PP
Reads the routes from a gzFile\&. Returns the number of bytes read on success, -1 on failure\&. 
.PP
Implements \fBDwm::GZReadable\fP\&.
.SS "template<typename _valueT > ssize_t \fBDwm::Ipv4Routes\fP< _valueT >::Read (int fd)\fR [inline]\fP, \fR [override]\fP, \fR [virtual]\fP"

.PP
Reads the routes from a file descriptor\&. Returns the number of bytes read on success, -1 on failure\&. 
.PP
Implements \fBDwm::DescriptorReadable\fP\&.
.SS "template<typename _valueT > std::istream & \fBDwm::Ipv4Routes\fP< _valueT >::Read (std::istream & is)\fR [inline]\fP, \fR [override]\fP, \fR [virtual]\fP"

.PP
Reads the routes from an istream\&. Returns the istream\&. 
.PP
Implements \fBDwm::StreamReadable\fP\&.
.SS "template<typename _valueT > void \fBDwm::Ipv4Routes\fP< _valueT >::SortByValue (std::vector< std::pair< \fBIpv4Prefix\fP, _valueT > > & target)\fR [inline]\fP"

.PP
Sorts the contained pair<Ipv4Prefix,_valueT> values into a vector, in descending order by the value stored for each prefix\&. For example, if you had an Ipv4Routes<uint32_t> object, \fRtarget\fP would contain the pair<Ipv4Prefix,_valueT> objects sorted in descending order by the uint32_t values\&. 
.SS "template<typename _valueT > uint64_t \fBDwm::Ipv4Routes\fP< _valueT >::StreamedLength () const\fR [inline]\fP, \fR [override]\fP, \fR [virtual]\fP"

.PP
Return the number of bytes that would be written if the object's Write(ostream &), Write(FILE *) or Write(int) member were called\&. These members would be inherited from \fBStreamWritable\fP, \fBFileWritable\fP or \fBDescriptorWritable\fP, respectively\&. 
.PP
Implements \fBDwm::StreamedLengthCapable\fP\&.
.SS "template<typename _valueT > size_t \fBDwm::Ipv4Routes\fP< _valueT >::Write (FILE * f) const\fR [inline]\fP, \fR [override]\fP, \fR [virtual]\fP"

.PP
Writes the routes to a FILE pointer\&. Returns 1 on success, 0 on failure\&. 
.PP
Implements \fBDwm::FileWritable\fP\&.
.SS "template<typename _valueT > int \fBDwm::Ipv4Routes\fP< _valueT >::Write (gzFile gzf) const\fR [inline]\fP, \fR [override]\fP, \fR [virtual]\fP"

.PP
Writes the routes to a gzFile\&. Returns the number of bytes written on success, -1 on failure\&. 
.PP
Implements \fBDwm::GZWritable\fP\&.
.SS "template<typename _valueT > ssize_t \fBDwm::Ipv4Routes\fP< _valueT >::Write (int fd) const\fR [inline]\fP, \fR [override]\fP, \fR [virtual]\fP"

.PP
Writes the routes to a file descriptor\&. Returns the number of bytes written on success, -1 on failure\&. 
.PP
Implements \fBDwm::DescriptorWritable\fP\&.
.SS "template<typename _valueT > std::ostream & \fBDwm::Ipv4Routes\fP< _valueT >::Write (std::ostream & os) const\fR [inline]\fP, \fR [override]\fP, \fR [virtual]\fP"

.PP
Writes the routes to an ostream\&. Returns the ostream\&. 
.PP
Implements \fBDwm::StreamWritable\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libDwm-0\&.0\&.20240716 from the source code\&.
