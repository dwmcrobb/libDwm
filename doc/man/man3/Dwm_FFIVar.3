.TH "Dwm::FFIVar< T, Enable >" 3 "libDwm-0.0.20240716" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Dwm::FFIVar< T, Enable > \- The main idea here is to encpasulate a scalar type to provide protection from interference\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <DwmFFIVar\&.hh>\fP
.SH "Detailed Description"
.PP 

.SS "template<class T, class Enable = void>
.br
class Dwm::FFIVar< T, Enable >"The main idea here is to encpasulate a scalar type to provide protection from interference\&. 

We do this by keeping a copy of the scalar, possibly bitwise inverted, and checking that the scalar and its copy match\&. This can be done manually by calling IsFFI(), but various operators call it when a read occurs\&. At the moment, these are wrapped in assert(), but later I'll provide a means of registering a callback or using a macro that can be redefined\&. On a fully hosted system we might still want abort() to get a core dump when desired, but in an embedded system we'll want something else\&.
.PP
It's worth noting that throwing an exception could be an elegant solution on a hosted system\&. But in embedded environments, and some hosted environments, exceptions might be intentionally disabled\&. If I use a macro to define what happens, theoretically one could throw, or call a callback, etc\&. I haven't done this work yet, saince the few times I've used this code, assert() has been what I wanted and the IsFFI() member of the class templates covered the cases where I needed a check in production code\&.
.PP
I have 3 class templates, each specialized for specific types: integral types, floating point types and pointer types\&. I have some trivial concepts that are used for the binary operators defined outside of class templates\&. Top level template class, intentionally empty\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for libDwm-0\&.0\&.20240716 from the source code\&.
