.TH "DwmFFIVar.hh" 3 "libDwm-0.0.20240716" \" -*- nroff -*-
.ad l
.nh
.SH NAME
DwmFFIVar.hh \- Class templates for simple Freedom From Interference (FFI) Note that this implementation uses C++20 constraints and concepts\&.  

.SH SYNOPSIS
.br
.PP
\fR#include <cassert>\fP
.br
\fR#include <type_traits>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBDwm::FFIVar< T, Enable >\fP"
.br
.RI "The main idea here is to encpasulate a scalar type to provide protection from interference\&. "
.ti -1c
.RI "class \fBDwm::FFIVar< T, typename std::enable_if< std::is_integral< T >::value >::type >\fP"
.br
.RI "Specialization for integral types\&. "
.ti -1c
.RI "class \fBDwm::FFIVar< T, typename std::enable_if< std::is_floating_point< T >::value >::type >\fP"
.br
.RI "Specialization for floating point types\&. No bitwise operators\&. "
.ti -1c
.RI "class \fBDwm::FFIVar< T, typename std::enable_if< std::is_pointer< T >::value >::type >\fP"
.br
.RI "Specialization for pointers\&. "
.in -1c
.SS "Concepts"

.in +1c
.ti -1c
.RI "concept \fBDwm::AreFFI_Addable\fP"
.br
.RI "Concepts to apply to binary operators\&. "
.ti -1c
.RI "concept \fBDwm::AreFFI_Subtractable\fP"
.br
.RI "T2 can be subtracted from T1 and yield a T1\&. i\&.e\&. { T1 - T2 } -> T1\&. "
.ti -1c
.RI "concept \fBDwm::AreFFI_Dividable\fP"
.br
.RI "T1 can be divided by T2 and yield a T1\&. i\&.e\&. { T1 / T2 } -> T1\&. "
.ti -1c
.RI "concept \fBDwm::AreFFI_Moduloable\fP"
.br
.RI "T1 modulo T2 yields a T1\&. i\&.e\&. { T1 % T2 } -> T1\&. "
.ti -1c
.RI "concept \fBDwm::AreFFI_Multipliable\fP"
.br
.RI "T1 can be multiplied by T2 and yield a T1\&. i\&.e\&. { T1 * T2 } -> T1\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename T1 , typename T2 , typename std::enable_if< AreFFI_Addable< T1, T2 > > > \fBFFIVar\fP< T1 > \fBDwm::operator+\fP (\fBFFIVar\fP< T1 > lhs, \fBFFIVar\fP< T2 > rhs)"
.br
.RI "Binary operators\&. "
.ti -1c
.RI "template<typename T1 , typename T2 , typename std::enable_if< AreFFI_Subtractable< T1, T2 > > > \fBFFIVar\fP< T1 > \fBDwm::operator\-\fP (\fBFFIVar\fP< T1 > lhs, \fBFFIVar\fP< T2 > rhs)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , typename std::enable_if< AreFFI_Multipliable< T1, T2 > > > \fBFFIVar\fP< T1 > \fBDwm::operator*\fP (\fBFFIVar\fP< T1 > lhs, \fBFFIVar\fP< T2 > rhs)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , typename std::enable_if< AreFFI_Dividable< T1, T2 > > > \fBFFIVar\fP< T1 > \fBDwm::operator/\fP (\fBFFIVar\fP< T1 > lhs, \fBFFIVar\fP< T2 > rhs)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , typename std::enable_if< AreFFI_Moduloable< T1, T2 > > > \fBFFIVar\fP< T1 > \fBDwm::operator%\fP (\fBFFIVar\fP< T1 > lhs, \fBFFIVar\fP< T2 > rhs)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< std::is_integral< T >::value >::type > \fBFFIVar\fP< T > \fBDwm::operator>>\fP (\fBFFIVar\fP< T > lhs, \fBFFIVar\fP< T > rhs)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< std::is_integral< T >::value >::type > \fBFFIVar\fP< T > \fBDwm::operator<<\fP (\fBFFIVar\fP< T > lhs, \fBFFIVar\fP< T > rhs)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< std::is_integral< T >::value >::type > \fBFFIVar\fP< T > \fBDwm::operator&\fP (\fBFFIVar\fP< T > lhs, \fBFFIVar\fP< T > rhs)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< std::is_integral< T >::value >::type > \fBFFIVar\fP< T > \fBDwm::operator|\fP (\fBFFIVar\fP< T > lhs, \fBFFIVar\fP< T > rhs)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< std::is_integral< T >::value >::type > \fBFFIVar\fP< T > \fBDwm::operator^\fP (\fBFFIVar\fP< T > lhs, \fBFFIVar\fP< T > rhs)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Class templates for simple Freedom From Interference (FFI) Note that this implementation uses C++20 constraints and concepts\&. 


.PP
\fBAuthor\fP
.RS 4
Daniel W\&. McRobb 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for libDwm-0\&.0\&.20240716 from the source code\&.
