.TH "Dwm::LoadBalancer< ItemT >::Worker" 3 "libDwm-0.0.20240716" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Dwm::LoadBalancer< ItemT >::Worker \- \fBWorker\fP class for \fBLoadBalancer\fP\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <DwmLoadBalancer\&.hh>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBWorker\fP (std::chrono::microseconds waitNotEmptyMicroseconds=std::chrono::microseconds(1000))"
.br
.RI "Constructs the worker\&. "
.ti -1c
.RI "virtual \fB~Worker\fP ()"
.br
.RI "Destructor\&. Stops the worker thread\&. "
.ti -1c
.RI "bool \fBAddWork\fP (const ItemT &item)"
.br
.RI "Adds a work item for the worker\&. "
.ti -1c
.RI "template<typename InputIterator > bool \fBAddWork\fP (InputIterator firstIter, InputIterator lastIter)"
.br
.RI "Adds work items for the worker\&. "
.ti -1c
.RI "uint32_t \fBQueueLength\fP () const"
.br
.RI "Returns the current length of the worker's work queue\&. "
.ti -1c
.RI "bool \fBReadyForWork\fP () const"
.br
.RI "Returns true if the worker is ready for more work (has room in its work queue and is running)\&. "
.ti -1c
.RI "bool \fBReadyForWork\fP (size_t numEntries) const"
.br
.RI "Returns true if the worker is ready for \fRnumEntries\fP units of work\&. "
.ti -1c
.RI "void \fBMaxWork\fP (uint32_t maxItems)"
.br
.RI "Sets the maximum length of the worker's work queue\&. "
.ti -1c
.RI "bool \fBStart\fP ()"
.br
.RI "Starts the worker\&. "
.ti -1c
.RI "void \fBStop\fP ()"
.br
.RI "Stops the worker\&. "
.ti -1c
.RI "bool \fBIsRunning\fP ()"
.br
.RI "Returns true if the worker's thread is running\&. "
.ti -1c
.RI "void \fBRun\fP ()"
.br
.RI "Runs the worker thread\&. "
.ti -1c
.RI "virtual void \fBProcessWork\fP (ItemT &item)=0"
.br
.RI "Pure virtual member to process a single work item\&. "
.ti -1c
.RI "virtual bool \fBProcessWork\fP (std::deque< ItemT > &items)"
.br
.RI "Process a deque of work items\&. "
.ti -1c
.RI "std::chrono::microseconds \fBWaitUsecs\fP () const"
.br
.RI "Returns the microseconds we'll wait for queue to be non-empty in our worker thread\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBThread::Queue\fP< ItemT > \fB_workQueue\fP"
.br
.ti -1c
.RI "std::atomic< bool > \fB_keepRunning\fP"
.br
.ti -1c
.RI "std::thread \fB_thread\fP"
.br
.ti -1c
.RI "std::atomic< std::chrono::microseconds > \fB_waitUsecs\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename ItemT>
.br
class Dwm::LoadBalancer< ItemT >::Worker"\fBWorker\fP class for \fBLoadBalancer\fP\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename ItemT > \fBDwm::LoadBalancer\fP< ItemT >::Worker::Worker (std::chrono::microseconds waitNotEmptyMicroseconds = \fRstd::chrono::microseconds(1000)\fP)\fR [inline]\fP"

.PP
Constructs the worker\&. \fRwaitForNotEmptyMicroseconds\fP is the period of time to wait for the work queue to become non-empty before checking again whether or not to continue\&. 
.SH "Member Function Documentation"
.PP 
.SS "template<typename ItemT > bool \fBDwm::LoadBalancer\fP< ItemT >::Worker::AddWork (const ItemT & item)\fR [inline]\fP"

.PP
Adds a work item for the worker\&. Returns true on success, false on failure\&. A reason for failure: the work queue is full\&. 
.SS "template<typename ItemT > template<typename InputIterator > bool \fBDwm::LoadBalancer\fP< ItemT >::Worker::AddWork (InputIterator firstIter, InputIterator lastIter)\fR [inline]\fP"

.PP
Adds work items for the worker\&. Returns true on success, false 
.br
 on failure\&. Reasons for failure: the work queue is full, or \fRlastIter\fP is equal to \fRfirstIter\fP\&. 
.SS "template<typename ItemT > virtual void \fBDwm::LoadBalancer\fP< ItemT >::Worker::ProcessWork (ItemT & item)\fR [pure virtual]\fP"

.PP
Pure virtual member to process a single work item\&. Obviously must be implemented by derived classes\&. 
.SS "template<typename ItemT > virtual bool \fBDwm::LoadBalancer\fP< ItemT >::Worker::ProcessWork (std::deque< ItemT > & items)\fR [inline]\fP, \fR [virtual]\fP"

.PP
Process a deque of work items\&. The default implementation does nothing and returns \fRfalse\fP\&. If you impelement this in your derived class, it should return \fRtrue\fP\&. 
.SS "template<typename ItemT > std::chrono::microseconds \fBDwm::LoadBalancer\fP< ItemT >::Worker::WaitUsecs () const\fR [inline]\fP"

.PP
Returns the microseconds we'll wait for queue to be non-empty in our worker thread\&. This is basically the longest possible time that our worker thread will be idle\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for libDwm-0\&.0\&.20240716 from the source code\&.
