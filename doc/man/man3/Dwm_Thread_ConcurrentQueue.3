.TH "Dwm::Thread::ConcurrentQueue< T >" 3 "libDwm-0.0.20240716" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Dwm::Thread::ConcurrentQueue< T > \- Concurrent queue template\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <DwmConcurrentQueue\&.hh>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBConcurrentQueue\fP (uint64_t maxLength=10000, useconds_t pushSleepUsecs=1000)"
.br
.RI "Constructor\&. "
.ti -1c
.RI "\fB~ConcurrentQueue\fP ()"
.br
.RI "Destructor\&. Walks the queue and deletes all entries\&. "
.ti -1c
.RI "bool \fBPopFront\fP (T &result)"
.br
.RI "If the queue is not empty, pops the front entry into \fRresult\fP and returns true\&. "
.ti -1c
.RI "bool \fBPopFront\fP (std::vector< T > &result)"
.br
.ti -1c
.RI "bool \fBPushBack\fP (const T &t)"
.br
.RI "Waits for the queue to not be full (see the \fBQueue\fP constructor), then pushes \fRt\fP onto the back of the queue and returns true\&. "
.ti -1c
.RI "bool \fBPushBack\fP (const std::vector< T > &t)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename T>
.br
class Dwm::Thread::ConcurrentQueue< T >"Concurrent queue template\&. 

This is based on an old article from Herb Sutter in Dr\&. Dobb's Journal, with modifications to support pushing and popping more than one entry at a time and reduction of the number of pointers\&.
.PP
The operations here are not wait-free, but I've tried to minimize contention\&. There is no contention between a producer (caller of \fBPushBack()\fP) and a consumer (caller of \fBPopFront()\fP)\&. Short periods of contention will exist among producers\&. Short periods of contention will exist among consumers\&.
.PP
In my typical use, I only have one producer and one consumer per \fBQueue\fP\&. Occasionally I have the need for one producer and multiple consumers (for example, one producer feeding 'work' to multiple 'worker' threads)\&. I rarely have a need for a single queue with multiple producers\&. If I need multiple producers, I almost always need (or want) multiple consumers\&. In those cases it almost always makes sense to have multiple queues, each with a single producer and a single consumer\&. For multiple wait-free producers, you've already thrown out the notion of ordered processing since you're not synchronizing the producers (else they'd be waiting for synchronization points)\&. In most such cases, the solution with the most concurrency is multiple queues\&.
.PP
Of course there are exceptions\&. For example, you might want one producer to feed a set of consumers who then act as producers to feed one consumer (break a problem apart for multiple worker threads, then put it back together with a single consumer thread)\&. But again, you've already thrown out strict ordering; that final consumer might as well be reading from multiple queues\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename T > \fBDwm::Thread::ConcurrentQueue\fP< T >::ConcurrentQueue (uint64_t maxLength = \fR10000\fP, useconds_t pushSleepUsecs = \fR1000\fP)\fR [inline]\fP"

.PP
Constructor\&. \fRmaxLength\fP is the maximum depth of the queue\&. When the queue reaches this depth, we will sleep \fRpushSleepUsecs\fP at a time until the queue is shallower than \fRmaxLength\fP\&. This allows a consuming thread to catch up with \fBPopFront()\fP\&. 
.SH "Member Function Documentation"
.PP 
.SS "template<typename T > bool \fBDwm::Thread::ConcurrentQueue\fP< T >::PopFront (T & result)\fR [inline]\fP"

.PP
If the queue is not empty, pops the front entry into \fRresult\fP and returns true\&. If the queue is empty, returns false\&. A caller may choose to sleep a short period of time when false is returned\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for libDwm-0\&.0\&.20240716 from the source code\&.
