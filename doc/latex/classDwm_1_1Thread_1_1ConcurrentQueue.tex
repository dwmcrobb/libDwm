\doxysection{Dwm\+::Thread\+::Concurrent\+Queue\texorpdfstring{$<$}{<} T \texorpdfstring{$>$}{>} Class Template Reference}
\hypertarget{classDwm_1_1Thread_1_1ConcurrentQueue}{}\label{classDwm_1_1Thread_1_1ConcurrentQueue}\index{Dwm::Thread::ConcurrentQueue$<$ T $>$@{Dwm::Thread::ConcurrentQueue$<$ T $>$}}


Concurrent queue template.  




{\ttfamily \#include $<$Dwm\+Concurrent\+Queue.\+hh$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classDwm_1_1Thread_1_1ConcurrentQueue_a873b6b00b360a2bcd63fa2e72c1854ce}{Concurrent\+Queue}} (uint64\+\_\+t max\+Length=10000, useconds\+\_\+t push\+Sleep\+Usecs=1000)
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
\Hypertarget{classDwm_1_1Thread_1_1ConcurrentQueue_a0023f301cbb0e967a8a0b40af1f79b28}\label{classDwm_1_1Thread_1_1ConcurrentQueue_a0023f301cbb0e967a8a0b40af1f79b28} 
{\bfseries \texorpdfstring{$\sim$}{\string~}\+Concurrent\+Queue} ()
\begin{DoxyCompactList}\small\item\em Destructor. Walks the queue and deletes all entries. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classDwm_1_1Thread_1_1ConcurrentQueue_a302e27db22c94e04396c6c37956b8e24}{Pop\+Front}} (T \&result)
\begin{DoxyCompactList}\small\item\em If the queue is not empty, pops the front entry into {\ttfamily result} and returns true. \end{DoxyCompactList}\item 
\Hypertarget{classDwm_1_1Thread_1_1ConcurrentQueue_a6712a3d19393b67d423bde0bd175e1d0}\label{classDwm_1_1Thread_1_1ConcurrentQueue_a6712a3d19393b67d423bde0bd175e1d0} 
bool {\bfseries Pop\+Front} (std\+::vector$<$ T $>$ \&result)
\item 
\Hypertarget{classDwm_1_1Thread_1_1ConcurrentQueue_a97f1b0f6ff6ca6080f079fbbedfa2b66}\label{classDwm_1_1Thread_1_1ConcurrentQueue_a97f1b0f6ff6ca6080f079fbbedfa2b66} 
bool {\bfseries Push\+Back} (const T \&t)
\begin{DoxyCompactList}\small\item\em Waits for the queue to not be full (see the \doxylink{classDwm_1_1Thread_1_1Queue}{Queue} constructor), then pushes {\ttfamily t} onto the back of the queue and returns true. \end{DoxyCompactList}\item 
\Hypertarget{classDwm_1_1Thread_1_1ConcurrentQueue_a15acd5f321a938f9c8621b2887577cf5}\label{classDwm_1_1Thread_1_1ConcurrentQueue_a15acd5f321a938f9c8621b2887577cf5} 
bool {\bfseries Push\+Back} (const std\+::vector$<$ T $>$ \&t)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename T$>$\newline
class Dwm\+::\+Thread\+::\+Concurrent\+Queue$<$ T $>$}
Concurrent queue template. 

This is based on an old article from Herb Sutter in Dr. Dobb\textquotesingle{}s Journal, with modifications to support pushing and popping more than one entry at a time and reduction of the number of pointers.

The operations here are not wait-\/free, but I\textquotesingle{}ve tried to minimize contention. There is no contention between a producer (caller of \doxylink{classDwm_1_1Thread_1_1ConcurrentQueue_a97f1b0f6ff6ca6080f079fbbedfa2b66}{Push\+Back()}) and a consumer (caller of \doxylink{classDwm_1_1Thread_1_1ConcurrentQueue_a302e27db22c94e04396c6c37956b8e24}{Pop\+Front()}). Short periods of contention will exist among producers. Short periods of contention will exist among consumers.

In my typical use, I only have one producer and one consumer per \doxylink{classDwm_1_1Thread_1_1Queue}{Queue}. Occasionally I have the need for one producer and multiple consumers (for example, one producer feeding \textquotesingle{}work\textquotesingle{} to multiple \textquotesingle{}worker\textquotesingle{} threads). I rarely have a need for a single queue with multiple producers. If I need multiple producers, I almost always need (or want) multiple consumers. In those cases it almost always makes sense to have multiple queues, each with a single producer and a single consumer. For multiple wait-\/free producers, you\textquotesingle{}ve already thrown out the notion of ordered processing since you\textquotesingle{}re not synchronizing the producers (else they\textquotesingle{}d be waiting for synchronization points). In most such cases, the solution with the most concurrency is multiple queues.

Of course there are exceptions. For example, you might want one producer to feed a set of consumers who then act as producers to feed one consumer (break a problem apart for multiple worker threads, then put it back together with a single consumer thread). But again, you\textquotesingle{}ve already thrown out strict ordering; that final consumer might as well be reading from multiple queues. 

\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{classDwm_1_1Thread_1_1ConcurrentQueue_a873b6b00b360a2bcd63fa2e72c1854ce}\index{Dwm::Thread::ConcurrentQueue$<$ T $>$@{Dwm::Thread::ConcurrentQueue$<$ T $>$}!ConcurrentQueue@{ConcurrentQueue}}
\index{ConcurrentQueue@{ConcurrentQueue}!Dwm::Thread::ConcurrentQueue$<$ T $>$@{Dwm::Thread::ConcurrentQueue$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{ConcurrentQueue()}{ConcurrentQueue()}}
{\footnotesize\ttfamily \label{classDwm_1_1Thread_1_1ConcurrentQueue_a873b6b00b360a2bcd63fa2e72c1854ce} 
template$<$typename T $>$ \\
\mbox{\hyperlink{classDwm_1_1Thread_1_1ConcurrentQueue}{Dwm\+::\+Thread\+::\+Concurrent\+Queue}}$<$ T $>$\+::\+Concurrent\+Queue (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{max\+Length}{ = {\ttfamily 10000}, }\item[{useconds\+\_\+t}]{push\+Sleep\+Usecs}{ = {\ttfamily 1000}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Constructor. 

{\ttfamily max\+Length} is the maximum depth of the queue. When the queue reaches this depth, we will sleep {\ttfamily push\+Sleep\+Usecs} at a time until the queue is shallower than {\ttfamily max\+Length}. This allows a consuming thread to catch up with \doxylink{classDwm_1_1Thread_1_1ConcurrentQueue_a302e27db22c94e04396c6c37956b8e24}{Pop\+Front()}. 

\doxysubsection{Member Function Documentation}
\Hypertarget{classDwm_1_1Thread_1_1ConcurrentQueue_a302e27db22c94e04396c6c37956b8e24}\index{Dwm::Thread::ConcurrentQueue$<$ T $>$@{Dwm::Thread::ConcurrentQueue$<$ T $>$}!PopFront@{PopFront}}
\index{PopFront@{PopFront}!Dwm::Thread::ConcurrentQueue$<$ T $>$@{Dwm::Thread::ConcurrentQueue$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{PopFront()}{PopFront()}}
{\footnotesize\ttfamily \label{classDwm_1_1Thread_1_1ConcurrentQueue_a302e27db22c94e04396c6c37956b8e24} 
template$<$typename T $>$ \\
bool \mbox{\hyperlink{classDwm_1_1Thread_1_1ConcurrentQueue}{Dwm\+::\+Thread\+::\+Concurrent\+Queue}}$<$ T $>$\+::\+Pop\+Front (\begin{DoxyParamCaption}\item[{T \&}]{result}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



If the queue is not empty, pops the front entry into {\ttfamily result} and returns true. 

If the queue is empty, returns false. A caller may choose to sleep a short period of time when false is returned. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{DwmConcurrentQueue_8hh}{Dwm\+Concurrent\+Queue.\+hh}}\end{DoxyCompactItemize}
